        -:    0:Source:test/testes.c
        -:    0:Graph:all_tests-testes.gcno
        -:    0:Data:all_tests-testes.gcda
        -:    0:Runs:1
        -:    1:#include "unity.h"
        -:    2:#include "unity_fixture.h"
        -:    3:#include "../src/sort.h"
        -:    4:
        -:    5:#define CERTO 0
        -:    6:#define ERRADO 1
        -:    7:
        -:    8:// Vetores de teste
        -:    9:// Se testar vetores negativos no Radix ou Counting dá seg fault
        -:   10:
        -:   11:int vet_asc[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        -:   12:int vet_desc[10] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
        -:   13:int vet_dup[12] = {3, 1, 2, 3, 2, 1, 3, 1, 2, 3, 2, 1};
        -:   14:int vet_neg[5] = {3,2,1,0,-1};
        -:   15:int vet_mixed[8] = {3, -1, 2, -3, 1, -2, 5, 0};
        -:   16:
        -:   17:void teste(int* vet_base, int size, int compare);
        -:   18:int negative_values(int* vet, int size);
        -:   19:
        -:   20:TEST_GROUP(Sorting);
        -:   21:
       10:   22:TEST_SETUP(Sorting){}
        -:   23:
       10:   24:TEST_TEAR_DOWN(Sorting){}
        -:   25:
        -:   26:// Testa vetor ascendente
        2:   27:TEST(Sorting, TestSortingAscending){
        1:   28:	teste(vet_asc, 10, CERTO);
        -:   29:	//free(vet_asc);
        1:   30:}
------------------
TEST_Sorting_TestSortingAscending_:
        1:   27:TEST(Sorting, TestSortingAscending){
        1:   28:	teste(vet_asc, 10, CERTO);
        -:   29:	//free(vet_asc);
        1:   30:}
------------------
TEST_Sorting_TestSortingAscending_run:
        1:   27:TEST(Sorting, TestSortingAscending){
------------------
        -:   31:
        -:   32:// Testa vetor descendente
        2:   33:TEST(Sorting, TestSortingDescending){
        1:   34:	teste(vet_desc, 10, CERTO);
        -:   35:	//free(vet_desc);
        1:   36:}
------------------
TEST_Sorting_TestSortingDescending_:
        1:   33:TEST(Sorting, TestSortingDescending){
        1:   34:	teste(vet_desc, 10, CERTO);
        -:   35:	//free(vet_desc);
        1:   36:}
------------------
TEST_Sorting_TestSortingDescending_run:
        1:   33:TEST(Sorting, TestSortingDescending){
------------------
        -:   37:
        -:   38:// Testa vetor com elementos repetidos
        2:   39:TEST(Sorting, TestSortingDuplicates){
        1:   40:	teste(vet_dup, 12, CERTO);
        -:   41:	//free(vet_dup);
        1:   42:}
------------------
TEST_Sorting_TestSortingDuplicates_:
        1:   39:TEST(Sorting, TestSortingDuplicates){
        1:   40:	teste(vet_dup, 12, CERTO);
        -:   41:	//free(vet_dup);
        1:   42:}
------------------
TEST_Sorting_TestSortingDuplicates_run:
        1:   39:TEST(Sorting, TestSortingDuplicates){
------------------
        -:   43:
        -:   44:// Teste vetor com elementos negativos
        -:   45:// Utiliza função auxiliar para verificar se os vetores possuem números negativos
        -:   46:// Se possuir, não testa Counting e Radix sort para evitar segmentation fault
        2:   47:TEST(Sorting, TestSortingNegative){
        1:   48:    teste(vet_neg, 5, CERTO);
    #####:   49:}
------------------
TEST_Sorting_TestSortingNegative_:
        1:   47:TEST(Sorting, TestSortingNegative){
        1:   48:    teste(vet_neg, 5, CERTO);
    #####:   49:}
------------------
TEST_Sorting_TestSortingNegative_run:
        1:   47:TEST(Sorting, TestSortingNegative){
------------------
        -:   50:
        -:   51:// Teste vetor com elementos positivos e negativos
        2:   52:TEST(Sorting, TestSortingMixed){
        1:   53:    teste(vet_mixed, 8, CERTO);
    #####:   54:}
------------------
TEST_Sorting_TestSortingMixed_:
        1:   52:TEST(Sorting, TestSortingMixed){
        1:   53:    teste(vet_mixed, 8, CERTO);
    #####:   54:}
------------------
TEST_Sorting_TestSortingMixed_run:
        1:   52:TEST(Sorting, TestSortingMixed){
------------------
        -:   55:
        -:   56:// Testa vetor com tamanho mínimo
        -:   57:// leak de memória
        2:   58:TEST(Sorting, TestSortingMinSize){
        1:   59:	int *vet_min = malloc(2 * sizeof(int));
        1:   60:	if (vet_min != NULL) {
        1:   61:		vet_min[0] = 2; 
        1:   62:		vet_min[1] = 1;
        1:   63:		teste(vet_min, 2, CERTO);
        -:   64:    }
        1:   65:	free(vet_min);
        1:   66:}
------------------
TEST_Sorting_TestSortingMinSize_:
        1:   58:TEST(Sorting, TestSortingMinSize){
        1:   59:	int *vet_min = malloc(2 * sizeof(int));
        1:   60:	if (vet_min != NULL) {
        1:   61:		vet_min[0] = 2; 
        1:   62:		vet_min[1] = 1;
        1:   63:		teste(vet_min, 2, CERTO);
        -:   64:    }
        1:   65:	free(vet_min);
        1:   66:}
------------------
TEST_Sorting_TestSortingMinSize_run:
        1:   58:TEST(Sorting, TestSortingMinSize){
------------------
        -:   67:
        -:   68:// Testa vetor com tamanho máximo
        -:   69:// leak de memória
        2:   70:TEST(Sorting, TestSortingMaxSize) {
        1:   71:	int *vet_max = malloc(20 * sizeof(int));
        1:   72:    if (vet_max != NULL) {
       21:   73:        for (int i = 0; i < 20; i++) {
       20:   74:            vet_max[i] = 20 - i;
        -:   75:        }
        1:   76:		teste(vet_max, 20, CERTO);
        -:   77:    }
        1:   78:	free(vet_max);
        1:   79:}
------------------
TEST_Sorting_TestSortingMaxSize_:
        1:   70:TEST(Sorting, TestSortingMaxSize) {
        1:   71:	int *vet_max = malloc(20 * sizeof(int));
        1:   72:    if (vet_max != NULL) {
       21:   73:        for (int i = 0; i < 20; i++) {
       20:   74:            vet_max[i] = 20 - i;
        -:   75:        }
        1:   76:		teste(vet_max, 20, CERTO);
        -:   77:    }
        1:   78:	free(vet_max);
        1:   79:}
------------------
TEST_Sorting_TestSortingMaxSize_run:
        1:   70:TEST(Sorting, TestSortingMaxSize) {
------------------
        -:   80:
        -:   81:// Testa um vetor com mais de 20 elementos (deve retornar erro)
        -:   82:// leak de memória 
        2:   83:TEST(Sorting, TestSortingInvalidSize) {
        1:   84:    int *vet_invalid = malloc(21 * sizeof(int));
        1:   85:    if (vet_invalid != NULL) {
       22:   86:        for (int i = 0; i < 21; i++) {
       21:   87:            vet_invalid[i] = 21 - i; 
        -:   88:        }
        1:   89:		teste(vet_invalid, 21, ERRADO);
        -:   90:    }
        1:   91:	free(vet_invalid);
        1:   92:}
------------------
TEST_Sorting_TestSortingInvalidSize_:
        1:   83:TEST(Sorting, TestSortingInvalidSize) {
        1:   84:    int *vet_invalid = malloc(21 * sizeof(int));
        1:   85:    if (vet_invalid != NULL) {
       22:   86:        for (int i = 0; i < 21; i++) {
       21:   87:            vet_invalid[i] = 21 - i; 
        -:   88:        }
        1:   89:		teste(vet_invalid, 21, ERRADO);
        -:   90:    }
        1:   91:	free(vet_invalid);
        1:   92:}
------------------
TEST_Sorting_TestSortingInvalidSize_run:
        1:   83:TEST(Sorting, TestSortingInvalidSize) {
------------------
        -:   93:
        -:   94:// Testa um vetor de tamanho 0
        2:   95:TEST(Sorting, TestSortingZeroSize) {
        1:   96:    int *vet_empty = malloc(0);  
        1:   97:    teste(vet_empty, 0, ERRADO);  
        1:   98:}
------------------
TEST_Sorting_TestSortingZeroSize_:
        1:   95:TEST(Sorting, TestSortingZeroSize) {
        1:   96:    int *vet_empty = malloc(0);  
        1:   97:    teste(vet_empty, 0, ERRADO);  
        1:   98:}
------------------
TEST_Sorting_TestSortingZeroSize_run:
        1:   95:TEST(Sorting, TestSortingZeroSize) {
------------------
        -:   99:
        2:  100:TEST(Sorting, TestNegativeValuesFunction) {
        1:  101:    TEST_ASSERT_EQUAL(1, negative_values(vet_neg, 5)); // Deve detectar negativo
        1:  102:    TEST_ASSERT_EQUAL(0, negative_values(vet_asc, 10)); // Não deve detectar negativo
        1:  103:}
------------------
TEST_Sorting_TestNegativeValuesFunction_:
        1:  100:TEST(Sorting, TestNegativeValuesFunction) {
        1:  101:    TEST_ASSERT_EQUAL(1, negative_values(vet_neg, 5)); // Deve detectar negativo
        1:  102:    TEST_ASSERT_EQUAL(0, negative_values(vet_asc, 10)); // Não deve detectar negativo
        1:  103:}
------------------
TEST_Sorting_TestNegativeValuesFunction_run:
        1:  100:TEST(Sorting, TestNegativeValuesFunction) {
------------------
        -:  104:
        -:  105:
        9:  106:void teste(int* vet_base, int size, int compare) {
        9:  107:    int status = 0;
        9:  108:    int *vet = malloc(size * sizeof(int));
        9:  109:    if (vet != NULL) {
        8:  110:		printf("começando\n\n");
        -:  111:
        8:  112:        if (negative_values(vet_base, size)) {
        2:  113:            TEST_IGNORE_MESSAGE("Ordenação com Radix ou Counting Sort falhou devido a números negativos.");
    #####:  114:            free(vet);
    #####:  115:            return;
        -:  116:        }
        -:  117:		
        -:  118:		// Counting Sort
        6:  119:		memcpy(vet, vet_base, size * sizeof(int));
        6:  120:		status += sort(vet, size, "On", COUNTING);
        6:  121:		printf("COUNTING + %d\n", status);
        -:  122:
        -:  123:		// Radix Sort
        6:  124:		 memcpy(vet, vet_base, size * sizeof(int));
        6:  125:		status += sort(vet, size, "On", RADIX);
        6:  126:		 printf("RADIX + %d\n", status);
        -:  127:        
        -:  128:        // Bubble Sort
        6:  129:        memcpy(vet, vet_base, size * sizeof(int));
        6:  130:        status += sort(vet, size, "On2", BUBBLE);
        6:  131:        printf("BUBBLE + %d\n", status);
        -:  132:        
        -:  133:        // Insertion Sort
        6:  134:        memcpy(vet, vet_base, size * sizeof(int));
        6:  135:        status += sort(vet, size, "On2", INSERTION);
        6:  136:        printf("INSERTION + %d\n", status);
        -:  137:        
        -:  138:        // Selection Sort
        6:  139:        memcpy(vet, vet_base, size * sizeof(int));
        6:  140:        status += sort(vet, size, "On2", SELECTION);
        6:  141:        printf("SELECTION + %d\n", status);
        -:  142:        
        -:  143:        // Heap Sort
        6:  144:        memcpy(vet, vet_base, size * sizeof(int));
        6:  145:        status += sort(vet, size, "Onlogn", HEAP);
        6:  146:        printf("HEAP + %d\n", status);
        -:  147:        
        -:  148:        // Merge Sort
        6:  149:        memcpy(vet, vet_base, size * sizeof(int));
        6:  150:        status += sort(vet, size, "Onlogn", MERGE);
        6:  151:        printf("MERGE + %d\n", status);
        -:  152:        
        -:  153:        // Quick Sort
        6:  154:        memcpy(vet, vet_base, size * sizeof(int));
        6:  155:        status += sort(vet, size, "Onlogn", QUICK);
        6:  156:        printf("QUICK + %d\n", status);
        -:  157:
        6:  158:        if(status > 0)
        1:  159:            status = 1;
        -:  160:
        6:  161:        TEST_ASSERT_EQUAL(compare, status);
        -:  162:    }
        7:  163:    free(vet);
        -:  164:}
        -:  165:
       10:  166:int negative_values(int* vet, int size) {
      104:  167:    for (int i = 0; i < size; i++) {
       97:  168:        if (vet[i] < 0) {
        3:  169:            return 1; // Retorna 1 se houver números negativos
        -:  170:        }
        -:  171:    }
        7:  172:    return 0; // Retorna 0 se não houver números negativos
        -:  173:}

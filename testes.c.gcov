        -:    0:Source:test/testes.c
        -:    0:Graph:all_tests-testes.gcno
        -:    0:Data:all_tests-testes.gcda
        -:    0:Runs:1
        -:    1:#include "unity.h"
        -:    2:#include "unity_fixture.h"
        -:    3:#include "../src/sort.h"
        -:    4:
        -:    5:#define CERTO 0
        -:    6:#define ERRADO 1
        -:    7:
        -:    8:// Vetores de teste
        -:    9:int vet_asc[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        -:   10:int vet_desc[10] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
        -:   11:int vet_dup[12] = {3, 1, 2, 3, 2, 1, 3, 1, 2, 3, 2, 1};
        -:   12:int vet_neg[5] = {-1, -3, -2, -5, -4};
        -:   13:int vet_mixed[8] = {3, -1, 2, -3, 1, -2, 5, 0};
        -:   14:
        -:   15:void teste(int* vet_base, int size, int compare);
        -:   16:
        -:   17:TEST_GROUP(Sorting);
        -:   18:
        8:   19:TEST_SETUP(Sorting){}
        -:   20:
        8:   21:TEST_TEAR_DOWN(Sorting){}
        -:   22:
        -:   23:// Testa vetor ascendente
        2:   24:TEST(Sorting, TestSortingAscending){
        1:   25:	teste(vet_asc, 10, CERTO);
    #####:   26:	free(vet_asc);
    #####:   27:}
------------------
TEST_Sorting_TestSortingAscending_:
        1:   24:TEST(Sorting, TestSortingAscending){
        1:   25:	teste(vet_asc, 10, CERTO);
    #####:   26:	free(vet_asc);
    #####:   27:}
------------------
TEST_Sorting_TestSortingAscending_run:
        1:   24:TEST(Sorting, TestSortingAscending){
------------------
        -:   28:
        -:   29:// Testa vetor descendente
        2:   30:TEST(Sorting, TestSortingDescending){
        1:   31:	teste(vet_desc, 10, CERTO);
    #####:   32:	free(vet_desc);
    #####:   33:}
------------------
TEST_Sorting_TestSortingDescending_:
        1:   30:TEST(Sorting, TestSortingDescending){
        1:   31:	teste(vet_desc, 10, CERTO);
    #####:   32:	free(vet_desc);
    #####:   33:}
------------------
TEST_Sorting_TestSortingDescending_run:
        1:   30:TEST(Sorting, TestSortingDescending){
------------------
        -:   34:
        -:   35:// Testa vetor com elementos repetidos
        2:   36:TEST(Sorting, TestSortingDuplicates){
        1:   37:	teste(vet_dup, 12, CERTO);
    #####:   38:	free(vet_dup);
    #####:   39:}
------------------
TEST_Sorting_TestSortingDuplicates_:
        1:   36:TEST(Sorting, TestSortingDuplicates){
        1:   37:	teste(vet_dup, 12, CERTO);
    #####:   38:	free(vet_dup);
    #####:   39:}
------------------
TEST_Sorting_TestSortingDuplicates_run:
        1:   36:TEST(Sorting, TestSortingDuplicates){
------------------
        -:   40:
        -:   41:// Teste vetor com elementos negativos
        2:   42:TEST(Sorting, TestSortingNegative){
        1:   43:	teste(vet_neg, 5, CERTO);
    #####:   44:	free(vet_neg);
    #####:   45:}
------------------
TEST_Sorting_TestSortingNegative_:
        1:   42:TEST(Sorting, TestSortingNegative){
        1:   43:	teste(vet_neg, 5, CERTO);
    #####:   44:	free(vet_neg);
    #####:   45:}
------------------
TEST_Sorting_TestSortingNegative_run:
        1:   42:TEST(Sorting, TestSortingNegative){
------------------
        -:   46:
        -:   47:// Teste vetor com elementos positivos e negativos
        2:   48:TEST(Sorting, TestSortingMixed){
        1:   49:	teste(vet_mixed, 8, CERTO);
    #####:   50:	free(vet_mixed);
    #####:   51:}
------------------
TEST_Sorting_TestSortingMixed_:
        1:   48:TEST(Sorting, TestSortingMixed){
        1:   49:	teste(vet_mixed, 8, CERTO);
    #####:   50:	free(vet_mixed);
    #####:   51:}
------------------
TEST_Sorting_TestSortingMixed_run:
        1:   48:TEST(Sorting, TestSortingMixed){
------------------
        -:   52:
        -:   53:// Testa vetor com tamanho mínimo
        2:   54:TEST(Sorting, TestSortingMinSize){
        1:   55:	int *vet_min = malloc(2 * sizeof(int));
        1:   56:	if (vet_min != NULL) {
        1:   57:		vet_min[0] = 2; 
        1:   58:		vet_min[1] = 1;
        1:   59:		teste(vet_min, 2, CERTO);
        -:   60:    }
    #####:   61:	free(vet_min);
    #####:   62:}
------------------
TEST_Sorting_TestSortingMinSize_:
        1:   54:TEST(Sorting, TestSortingMinSize){
        1:   55:	int *vet_min = malloc(2 * sizeof(int));
        1:   56:	if (vet_min != NULL) {
        1:   57:		vet_min[0] = 2; 
        1:   58:		vet_min[1] = 1;
        1:   59:		teste(vet_min, 2, CERTO);
        -:   60:    }
    #####:   61:	free(vet_min);
    #####:   62:}
------------------
TEST_Sorting_TestSortingMinSize_run:
        1:   54:TEST(Sorting, TestSortingMinSize){
------------------
        -:   63:
        -:   64:// Testa vetor com tamanho máximo
        2:   65:TEST(Sorting, TestSortingMaxSize) {
        1:   66:	int *vet_max = malloc(20 * sizeof(int));
        1:   67:    if (vet_max != NULL) {
        -:   68:		// Preenche o vetor em ordem decrescente
       21:   69:        for (int i = 0; i < 20; i++) {
       20:   70:            vet_max[i] = 20 - i;
        -:   71:        }
        1:   72:		teste(vet_max, 20, CERTO);
        -:   73:    }
    #####:   74:	free(vet_max);
    #####:   75:}
------------------
TEST_Sorting_TestSortingMaxSize_:
        1:   65:TEST(Sorting, TestSortingMaxSize) {
        1:   66:	int *vet_max = malloc(20 * sizeof(int));
        1:   67:    if (vet_max != NULL) {
        -:   68:		// Preenche o vetor em ordem decrescente
       21:   69:        for (int i = 0; i < 20; i++) {
       20:   70:            vet_max[i] = 20 - i;
        -:   71:        }
        1:   72:		teste(vet_max, 20, CERTO);
        -:   73:    }
    #####:   74:	free(vet_max);
    #####:   75:}
------------------
TEST_Sorting_TestSortingMaxSize_run:
        1:   65:TEST(Sorting, TestSortingMaxSize) {
------------------
        -:   76:
        -:   77:// Testa um vetor com mais de 20 elementos (deve retornar erro)
        2:   78:TEST(Sorting, TestSortingInvalidSize) {
        1:   79:    int *vet_invalid = malloc(21 * sizeof(int));
        1:   80:    if (vet_invalid != NULL) {
       22:   81:        for (int i = 0; i < 21; i++) {
       21:   82:            vet_invalid[i] = 21 - i; // Preenche o vetor em ordem decrescente
        -:   83:        }
        1:   84:		teste(vet_invalid, 21, ERRADO);
        -:   85:    }
        1:   86:	free(vet_invalid);
        1:   87:}
------------------
TEST_Sorting_TestSortingInvalidSize_:
        1:   78:TEST(Sorting, TestSortingInvalidSize) {
        1:   79:    int *vet_invalid = malloc(21 * sizeof(int));
        1:   80:    if (vet_invalid != NULL) {
       22:   81:        for (int i = 0; i < 21; i++) {
       21:   82:            vet_invalid[i] = 21 - i; // Preenche o vetor em ordem decrescente
        -:   83:        }
        1:   84:		teste(vet_invalid, 21, ERRADO);
        -:   85:    }
        1:   86:	free(vet_invalid);
        1:   87:}
------------------
TEST_Sorting_TestSortingInvalidSize_run:
        1:   78:TEST(Sorting, TestSortingInvalidSize) {
------------------
        -:   88:
        8:   89:void teste(int* vet_base, int size, int compare) {
        -:   90:	int status;
        8:   91:    int *vet = malloc(size * sizeof(int));
        8:   92:    if (vet != NULL) {
        -:   93:		// Counting Sort
        8:   94:        memcpy(vet, vet_base, size * sizeof(int));
        8:   95:        status = sort(vet, size, "Onlogn", COUNTING);
        8:   96:        TEST_ASSERT_EQUAL(compare, status);
        -:   97:		// Radix Sort
        1:   98:		memcpy(vet, vet_base, size * sizeof(int));
        1:   99:        status = sort(vet, size, "Onlogn", RADIX);
        1:  100:        TEST_ASSERT_EQUAL(compare, status);
        -:  101:		// Bubble Sort
        1:  102:		memcpy(vet, vet_base, size * sizeof(int));
        1:  103:        status = sort(vet, size, "Onlogn", BUBBLE);
        1:  104:        TEST_ASSERT_EQUAL(compare, status);
        -:  105:		// Insertion Sort
        1:  106:		memcpy(vet, vet_base, size * sizeof(int));
        1:  107:        status = sort(vet, size, "Onlogn", INSERTION);
        1:  108:        TEST_ASSERT_EQUAL(compare, status);
        -:  109:		// Selection Sort
        1:  110:		memcpy(vet, vet_base, size * sizeof(int));
        1:  111:        status = sort(vet, size, "Onlogn", SELECTION);
        1:  112:        TEST_ASSERT_EQUAL(compare, status);
        -:  113:		// Heap Sort
        1:  114:		memcpy(vet, vet_base, size * sizeof(int));
        1:  115:        status = sort(vet, size, "Onlogn", HEAP);
        1:  116:        TEST_ASSERT_EQUAL(compare, status);
        -:  117:		// Merge Sort
        1:  118:		memcpy(vet, vet_base, size * sizeof(int));
        1:  119:        status = sort(vet, size, "Onlogn", MERGE);
        1:  120:        TEST_ASSERT_EQUAL(compare, status);
        -:  121:		// Quick Sort
        1:  122:		memcpy(vet, vet_base, size * sizeof(int));
        1:  123:        status = sort(vet, size, "Onlogn", QUICK);
        1:  124:        TEST_ASSERT_EQUAL(compare, status);
        -:  125:    }
        1:  126:	free(vet);
        1:  127:}
